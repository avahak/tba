<!DOCTYPE html>
<html>
<head>
    <title>Julia Set WebGL</title>
</head>
<body>
    <div id="webgl-container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Setup variables
        let scene, camera, renderer;
        let mouse = { x: 0, y: 0 };
        let juliaShaderMaterial;

        // Initialize scene
        scene = new THREE.Scene();

        // Create a camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 1;

        // Create a WebGL renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("webgl-container").appendChild(renderer.domElement);

        // Create the Julia set shader
        const juliaVertexShader = `
            void main() {
                gl_Position = vec4(position, 1.0);
            }
        `;

        const juliaFragmentShader = `
            uniform vec2 mouse;
            void main() {
                vec2 c = vec2(mouse.x * 2.0 - 1.0, mouse.y * 2.0 - 1.0);
                vec2 z = gl_FragCoord.xy / resolution - 0.5;
                for (int i = 0; i < 100; i++) {
                    z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
                    if (length(z) > 2.0) {
                        gl_FragColor = vec4(float(i) / 100.0, 0.0, 0.0, 1.0);
                        return;
                    }
                }
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            }
        `;

        juliaShaderMaterial = new THREE.ShaderMaterial({
            uniforms: { mouse: { value: new THREE.Vector2() } },
            vertexShader: juliaVertexShader,
            fragmentShader: juliaFragmentShader
        });

        // Create a quad to render the Julia set
        const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([-1, -1, 3, -1, -1, 3]);
        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 2));
        const quad = new THREE.Mesh(geometry, juliaShaderMaterial);
        scene.add(quad);

        // Handle mouse movement
        document.addEventListener('mousemove', (event) => {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = (event.clientX - rect.left) / rect.width;
            mouse.y = 1.0 - (event.clientY - rect.top) / rect.height;
            juliaShaderMaterial.uniforms.mouse.value = new THREE.Vector2(mouse.x, mouse.y);
        });

        // Animate the scene
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
